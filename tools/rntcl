#!/usr/local/bin/pike
// -*- Pike -*-

// RNTCL, a front-end to MS VC++ and Intel ICL/ECL with options similar to GCC
// Written by Fredrik Hubinette & Henrik Grubbström.

inherit "lib.pike";

// #define WIN64

#ifdef ECL
#ifdef WIN64
constant compiler="ecl";
#else /* !WIN64 */
constant compiler="icl";
#endif /* WIN64 */
#else /* !ECL */
constant compiler="cl";
#endif /* ECL */

constant default_cflags = ({
#ifdef ECL
  "-Wp64",	// Generate warnings for loss of precision.
  //"-W4",	// Maximum verbosity.
  "-W3",	// More warnings.
#else /* !ECL */
  "-Zm300",	// Memory allocation limit
  "-Ge",	// Activate stack probes
  "-F8388608",	// Stack size
  "-GR",	// Runtime type information (RTTI)
#endif /* ECL */
#ifdef WIN64
  "-D__WIN64__",
  "-D_WIN64",
#else /* !WIN64 */
  "-D__WIN32__",
  "-D_WIN32",
#endif /* WIN64 */
  "-D__NT__",
//    "-D__STDC__",  
  "-nologo",	// Supress banner
});

// Verbose is default for now, this can be turned off one this
// frontend has been refined to where it does not require more
// debugging.

int verbose=0;

// Temporary variable
int linking_failed;

// Files to remove upon exit
array(string) tmpfiles=({});

void exit(int code)
{
  if(getenv("CLEANUP")!="no")
    Array.map(tmpfiles,rm);

  predef::exit(code);
}

string get_ext(string file)
{
  sscanf(file=lower_case(reverse(file)),"%s.",file);
  return reverse(file);
}

string remove_ext(string file)
{
  sscanf(file=reverse(file),"%*s.%s",file,file);
  return reverse(file);
}

string o_to_obj(string fname)
{
  if (fname[sizeof(fname)-2..] == ".o") {
    return fname + "bj";
  }
  return fname;
}

array|object paranoia_stat(string f)
{
  for (int i=0; i < 10; i++) {
    array|object st = file_stat(f);
    if (st) return st;
    sleep(0.1);
  }
  return file_stat(f);
}

int main(int argc, array(string) argv)
{
//	werror("%O\n",argv);
  array(string) ldopts=({"-INCREMENTAL:no"});
  array(string) cflags=default_cflags;

  string target="exe";
  int debug,optimize,share,dynamic;
  string output, wantfile;

  array opts=Getopt.find_all_options(argv, aggregate(
    ({"oper_pre",Getopt.NO_ARG, ({"-E"}) }),
    ({"oper_asm",Getopt.NO_ARG, ({"-S"}) }),
    ({"oper_comp",Getopt.NO_ARG, ({"-c"}) }),	
    ({"verbose",Getopt.NO_ARG, ({"-v"}) }),	
    ({"debug",Getopt.MAY_HAVE_ARG, ({"-g"}) }),
    ({"optimize",Getopt.MAY_HAVE_ARG, ({"-O"}) }),
    ({"inline",Getopt.MAY_HAVE_ARG, ({"-Q"}) }),
    ({"include",Getopt.HAS_ARG, ({"-I"}) }),
    ({"link",Getopt.HAS_ARG, ({"-l"}) }),
    ({"share",Getopt.MAY_HAVE_ARG, ({"-s"}) }),
    ({"ignore",Getopt.MAY_HAVE_ARG, ({"-t"}) }),
    ({"dynamic",Getopt.HAS_ARG, ({"-r"}) }),
    ({"ldpath",Getopt.HAS_ARG, ({"-L"}) }),
    ({"ignore",Getopt.HAS_ARG, ({"-R"}) }),
    ({"warn",Getopt.MAY_HAVE_ARG, ({"-W"}) }),
    ({"define",Getopt.HAS_ARG, ({"-D"}) }),
    ({"undefine",Getopt.HAS_ARG, ({"-U"})}),
    ({"output",Getopt.HAS_ARG, ({"-o"}) }),
    ({"export",Getopt.HAS_ARG, ({"--export"}) })
    ));
  foreach(opts, array option)
    {
      switch(option[0])
      {
	case "dynamic":
	  dynamic++;
	  ldopts+=({
	    "-DELAY:nobind",
	      "-OPT:noref" // This might not be required
	      });
	  break;
	case "verbose":
	  verbose++;
	  ldopts+=({"-VERBOSE:lib"});
	  break;

	case "export": // fixme
//	  ldopts+=({"export",option[1]+"_"});
	  break;

	case "share": // fixme
	  switch(option[1])
	  {
	    case "hare":
	    case "hared":
	      share=1;
	      target="dll";
	      break;

	    case "tatic":
	      /* Not yet implemented */
	      break;
	  }
	  break;
	  
	case "oper_pre":
	  cflags+=({ "-E" });
	  target="-";
	  break;

        case "oper_asm":
	  cflags+=({ "-S" });
	  target="asm";
	  break;

	case "oper_comp":
	  target="obj";
	  cflags+=({ "-c" });
	  break;

	case "debug":
	  cflags+=({
	    "-Z7",
	    "-Zi",   // This flag prevents parallell compilation
//	    "-FR",   // This flag confuses libtool
//	    "-Yd",
	  });
	  debug=1;
	  break;
	  
	case "optimize":
	  if(!option[1]) option[1]=1;
	  switch(optimize=(int)option[1])
	  {
	    case 0: optimize=0; break;
	    case 1: cflags+=({"-O1"}); break;
	    case 2:
#ifdef ECL
	      cflags+=({"-O2"});
#else /* !ECL */
#ifdef WIN64
	      cflags += ({
		"-O"	// Optimization flags:
		"b"	//   Control inline expansion
		"2"	//   Create fast code
		// Disabled due to optimizer bugs in XP Platform SDK Beta 2.
		//"g"	//   Enable global optimizer
		"i"	//   Use intrinsic functions
		"t"	//   Favour fast code
	      });
#else /* !WIN64 */
	      cflags += ({
		"-O"	// Optimization flags:
		"b"	//   Control inline expansion
		"2"	//   Create fast code
		"g"	//   Enable global optimizer
		"i"	//   Use intrinsic functions
		"t"	//   Favour fast code
		"y",	//   Omit frame pointer
		"-GB",	// Optimize for Pentium
	      });
#endif /* WIN64 */
#endif /* ECL */
	      break;
	    case 3..:
	      break;
	  }
	  break;

        case "inline":
	  if (option[1] == "ip") {
	    cflags+=({"-Qip"});
	  }
	  break;

	case "include":
	  // Avoid searching 'local' include dirs.
	  // This is not a very pretty solution.
	  if(sscanf(option[1],"/usr/include/%*s") ||
	     sscanf(option[1],"/usr/local/%*s"))
	    break;
	  
	  cflags+=({"-I"+fixpath(option[1])});
	  break;

	case "link":
	  // -lm and -lc are automatically handled ?
	  if(option[1]=="m" || option[1]=="c") break;

	  // We optimiza a little, no need to bring in the same
	  // library many times in a row.
//	  if(cflags[-1]!=option[1]+".lib")
//	  if(search(cflags,option[1]+".lib")!=-1)
	    cflags-=({option[1]+".lib"});
	    cflags+=({option[1]+".lib"});
	  break;
	  
        case "warn":
	  if(option[1])
	  {
	    // This allows us to pass options to the linker
	    if(sscanf(option[1],"l,%s",string tmp))
	    {
	      // This was done for my convenience, it can be taken
	      // out once smartlink has been fixed to not use absoute
	      // paths for the 'uname' binary.
	      if(sscanf(tmp,"-rpath%*s")) break;
	      
	      ldopts+=({tmp});
	      break;
	    }
	  }

	  // More options should be recognized, options which are not
	  // recognized should generate warning/error messages.
	  switch(option[1])
	  {
	    case "all": cflags+=({"-W4"}); break;
            // Not supported, but in the manual...
	    case "X": cflags+=({"-WX"}); break;
	    default: cflags+=({"-W3"}); break;
	  }
	  break;

        case "ldpath":
	  ldopts+=({"-LIBPATH:"+fixpath(option[1])});
	  break;
	  
	case "define": cflags+=({"-D"+option[1]}); break;
	case "undefine": cflags+=({"-U"+option[1]}); break;
	case "output":
	  output=option[1];
	  break;
      }
    }

  // Scan through the remaining arguments
  argv=Getopt.get_args(argv);
  cflags+=Array.map(Array.map(argv[1..],fixpath), o_to_obj);

  foreach(argv[1..], string tmp)
  {
    if(tmp[0]=='-')
    {
      werror("Unrecognized option "+tmp+".\n");
      exit(1);
    }
  }

  switch(target)
  {
    case "exe":
      if(!output) output="a.out";
      cflags+=({"-Fe"+fixpath(output)+".exe","BINMODE.OBJ"});
//      cflags+=({"-MT" + (debug?"d":"") });
      wantfile=output+".exe";
      break;

    case "obj":
      if(!output)
	output=basename(remove_ext(argv[1])+".o");
      cflags+=({"-Fo"+fixpath(output+"bj")});
      wantfile=output;
      break;

    case "asm":
      if(!output)
        output=basename(remove_ext(argv[1])+".s");
      cflags+=({"-Fa"+fixpath(output)});
      wantfile=output;
      break;

    case "dll":
      if(output)
	cflags+=({"-Fe"+fixpath(output)});
      else
	output=remove_ext(argv[1])+".dll";

#ifndef WIN64
      cflags+=({"-MD" + (/*debug?"d":*/""), "-LD" + (/*debug?"d":*/"")});
#endif /* !WIN64 */
      wantfile=output;
      break;

    case "-":
  }


  cflags+=({"-MT" /* + (debug?"d":"") */ });

  if(output) rm(output);

  array(string) cmd = ({ compiler }) + cflags;

  switch(target)
  {
    case "exe":
    case "dll":
      if(debug)
      {
	array libs=({"libc.lib","libcd.lib",
		     "libcmt.lib","libcmtd.lib",
		     "msvcrt.lib","msvcrtd.lib"});

	string lib=(/*debug?"libcmtd.lib":*/"libcmt.lib");
	libs-=({ lib });
	for(int e=0;e<sizeof(libs);e++)
	  ldopts+=({"-nodefaultlib:"+libs[e]});


	ldopts = ({ 
	  "-fixed:no",
	  "-debug",
//	  "-PDB:NONE",
	  "-DEBUGTYPE:BOTH",
	  "-DEBUG",
	}) + ldopts;
	if(dynamic)
	  ldopts += ({"-DEBUGTYPE:BOTH"});
      }
      else if(dynamic)
      {
	ldopts = ({ "-DEBUG", "-DEBUGTYPE:COFF"}) + ldopts;
      }

      break;

    default:
      break;
  }

  if(sizeof(ldopts))
    cmd += ({"-link" }) + ldopts;

  int ret;
  if(verbose && target!="-")
  { 
    werror("   %s\n",cmd*" ");
    ret=do_cmd(cmd);
  }else{
    int first_line=1;
    int forced_error=0;
    string trailer = "";
    // cl.exe and ecl.exe echo the file name of the file we are compiling
    // first, we need to get rid of that to make configure behave.
    // CL: We also convert warning D4002 into an error.
    // ECL: We also convert warning 147 into an error, and command line
    //      remark "option not supported" into an error.
    ret=silent_do_cmd(cmd, lambda(string line) 
		      {
			trailer += line;
			array(string) lines = trailer/"\n";
			if (sizeof(lines) < 2) return;
			if(first_line)
			{
			  // Strip first line.
			  if (verbose && (target != "-")) {
			    write(lines[0]+"\n");
			  }
			  lines = lines[1..];
			  first_line = 0;
			}
			trailer = lines[-1];
			lines = lines[..sizeof(lines)-2];
			for(int i; i < sizeof(lines); i++) {
#ifdef ECL
			  // Warning 147 is prototype mismatch.
			  // for some reason this isn't an error.
			  // We make it an error...
			  if (search(lines[i], "warning #147:") != -1) {
			    forced_error = 1;
			    lines[i] = replace(lines[i],
					       "warning #147:",
					       "error #147:");
			  } else {
			    // Make it possible to test if flags are supported.
			    if (search(lines[i],
				       "Command line remark: option '") != -1){
			      if (search(lines[i], "' not supported") != -1) {
				forced_error = 1;
			      }
			    }
			  }
#else /* !ECL */
			  if (search(lines[i],
				     "Command line warning D4002") != -1) {
			    forced_error=1;
			    lines[i] = replace(lines[i],
					       "Command line warning D4002",
					       "Command line error D4002");
			  }
#endif /* ECL */
			}
			if (sizeof(lines)) {
			  write(lines*"\n" + "\n");
			}
		      },1);
    if (sizeof(trailer)) {
      // Shouldn't happen, but...
      write(trailer);
    }
    ret = ret || forced_error;
  }

  if(ret)
  {
    werror("CL returned error code %d.\n",ret);
    exit(ret);
  }

  if(wantfile)
  {
    if (target == "obj") {
      if(!paranoia_stat(wantfile+"bj"))
      {
	werror("RNTCL: output file not generated (%s).\n",
	       wantfile+"bj");
	exit(1);
      }
      rm(wantfile);
      if (catch {
	hardlink(wantfile+"bj", wantfile);
      }) {
	string s = Stdio.read_bytes(wantfile+"bj");
	if (!s) {
	  werror("RNTCL: Failed to read output file (%s).\n",
		 wantfile+"bj");
	  exit(1);
	}
	if (Stdio.write_file(wantfile, s) != sizeof(s)) {
	  werror("RNTCL: Failed to write all of output file (%s).\n",
		 wantfile);
	  exit(1);
	}
      }
    }
    if(!paranoia_stat(wantfile))
    {
      werror("RNTCL: output file not generated (%s).\n",wantfile);
      exit(1);
    }
  }

  if(target=="exe" && !share)
  {
    rm(output);
    Stdio.write_file(output,
		     "#!/usr/local/bin/pike\n"
		     "inherit \""+find_lib_location()+"\";\n"
		     "int main(int argc, array(string) argv) {\n"
		     "  if (lower_case(getenv(\"CROSSCOMPILING\")||\"no\") != \"no\")\n"
		     "    exit(1);\n"
		     "  argv[0]=getenv(\"NTDRIVE\")+fixpath(follow_symlinks(combine_path(getcwd(),argv[0]))+\".exe\");\n"
		     "  exit(silent_do_cmd(argv));\n"
		     "}\n");
    chmod(output,0755);
  }

  exit(ret);
}
